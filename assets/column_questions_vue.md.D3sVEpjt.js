import{_ as o,c as a,a2 as t,o as i}from"./chunks/framework.DqyS5ajJ.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"column/questions/vue.md","filePath":"column/questions/vue.md"}'),r={name:"column/questions/vue.md"};function d(c,e,l,n,s,u){return i(),a("div",null,e[0]||(e[0]=[t('<h2 id="vue面试题" tabindex="-1">Vue面试题 <a class="header-anchor" href="#vue面试题" aria-label="Permalink to &quot;Vue面试题&quot;">​</a></h2><h3 id="_1、vue-有了数据响应式-为何还要-diff" tabindex="-1">1、Vue 有了数据响应式，为何还要 diff ？ <a class="header-anchor" href="#_1、vue-有了数据响应式-为何还要-diff" aria-label="Permalink to &quot;1、Vue 有了数据响应式，为何还要 diff ？&quot;">​</a></h3><blockquote><p>Vue 中的数据响应式和虚拟 DOM 的 diff 算法是两个不同的概念，它们分别解决了不同的问题，相互协作以提高页面渲染的效率和性能。</p></blockquote><p><strong>数据响应式</strong></p><p>Vue 的数据响应式系统通过 <code>Object.defineProperty</code> 或者 ES6 的 <code>Proxy</code> 来实现，主要解决了以下问题：</p><ol><li><strong>数据绑定</strong>：保证了视图与数据的同步更新，当数据发生变化时，视图会自动更新，避免了手动操作 DOM 的繁琐和易出错性。</li><li><strong>依赖追踪</strong>：Vue 能够追踪每个数据的依赖关系，即哪些组件或者计算属性依赖于某个数据。当数据变化时，自动更新依赖的组件或者计算属性。</li></ol><p><strong>虚拟 DOM 和 Diff 算法</strong></p><blockquote><p>虚拟 DOM 是一种内存中的表示结构，它是对真实 DOM 的抽象。Diff 算法是一种高效更新 DOM 的策略，它通过比较新旧虚拟 DOM 树的差异，最小化了更新操作，提高了页面的渲染效率。</p></blockquote><h4 id="为什么还需要-diff-算法" tabindex="-1">为什么还需要 Diff 算法？ <a class="header-anchor" href="#为什么还需要-diff-算法" aria-label="Permalink to &quot;为什么还需要 Diff 算法？&quot;">​</a></h4><ol><li><strong>性能优化</strong>：直接操作真实 DOM 是非常昂贵的，而虚拟 DOM 可以在内存中快速进行比较和计算差异。Diff 算法帮助减少了更新操作的次数和范围，从而提升了页面渲染的性能。</li><li><strong>批量更新</strong>：Diff 算法能够将多次 DOM 更新操作合并为一次，避免了频繁的 DOM 操作，减少了浏览器的重排和重绘。</li><li><strong>跨平台兼容</strong>：虚拟 DOM 和 Diff 算法使得 Vue 可以运行在不同的平台上，例如浏览器、Weex 等，统一了渲染逻辑和数据响应式的实现。</li><li><strong>更新效率</strong>：即使是响应式系统可以自动更新视图，但是如果每次数据变化都直接操作真实 DOM，可能会带来性能问题。Diff 算法可以智能地比较新旧 DOM 树的变化，只更新必要的部分，从而提高了更新效率。</li></ol><h3 id="_2-vue3-为什么要引入-composition-api" tabindex="-1">2：vue3 为什么要引入 Composition API ？ <a class="header-anchor" href="#_2-vue3-为什么要引入-composition-api" aria-label="Permalink to &quot;2：vue3 为什么要引入 Composition API ？&quot;">​</a></h3><h4 id="_1-更好的代码组织和重用" tabindex="-1">1. 更好的代码组织和重用 <a class="header-anchor" href="#_1-更好的代码组织和重用" aria-label="Permalink to &quot;1. 更好的代码组织和重用&quot;">​</a></h4><p>在 Vue 2 中，使用选项式 API（Options API）来定义组件的逻辑，通常将数据、方法、计算属性和生命周期钩子分开写在不同的配置对象中。当组件变得复杂时，不同功能的代码可能会散落在各个部分，难以维护和重用。</p><h4 id="_2-更好的逻辑复用" tabindex="-1">2. 更好的逻辑复用 <a class="header-anchor" href="#_2-更好的逻辑复用" aria-label="Permalink to &quot;2. 更好的逻辑复用&quot;">​</a></h4><p>在 Vue 2 中，逻辑复用主要通过 mixins 和 scoped slots 实现，但它们都有一些缺点，比如命名冲突和代码可读性差。</p><p>Composition API 通过组合函数（composable functions）来实现逻辑复用，这些函数可以在多个组件之间共享和复用逻辑，避免了 mixins 的缺点。</p><h4 id="_3-更好的-typescript-支持" tabindex="-1">3. 更好的 TypeScript 支持 <a class="header-anchor" href="#_3-更好的-typescript-支持" aria-label="Permalink to &quot;3. 更好的 TypeScript 支持&quot;">​</a></h4><p>Composition API 天然地支持 TypeScript，使得类型推断和类型检查更为自然和方便。相比于 Options API，通过 Composition API 定义的逻辑更容易进行类型声明和类型推断，提升了开发体验。</p><h4 id="_4-适应函数式编程趋势" tabindex="-1">4. 适应函数式编程趋势 <a class="header-anchor" href="#_4-适应函数式编程趋势" aria-label="Permalink to &quot;4. 适应函数式编程趋势&quot;">​</a></h4><p>Composition API 借鉴了函数式编程的思想，将逻辑封装成函数，使得代码更加简洁、模块化、可测试，同时也更符合现代 JavaScript 开发趋势。</p><h4 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h4><p>Vue 3 引入 Composition API 主要是为了提升代码组织和复用性、提供更好的 TypeScript 支持、适应函数式编程趋势，并且解决 Vue 2 中存在的一些问题。通过 Composition API，可以让组件逻辑更加清晰、灵活和易于维护。</p><h3 id="_3、-vue-事件机制-并手写-on、-off、-emit、-once" tabindex="-1">3、 Vue 事件机制，并手写$on、$off、$emit、$once <a class="header-anchor" href="#_3、-vue-事件机制-并手写-on、-off、-emit、-once" aria-label="Permalink to &quot;3、 Vue 事件机制，并手写$on、$off、$emit、$once&quot;">​</a></h3><blockquote><p>Vue 的事件机制允许组件之间进行通信，通过 <code>$on</code>、<code>$off</code>、<code>$emit</code> 和 <code>$once</code> 等方法进行事件的订阅、取消订阅、触发和一次性订阅。我们可以通过手写这些方法来理解其工作原理。</p></blockquote><h4 id="vue-事件机制" tabindex="-1">Vue 事件机制 <a class="header-anchor" href="#vue-事件机制" aria-label="Permalink to &quot;Vue 事件机制&quot;">​</a></h4><ol><li><strong><code>$on(event, callback)</code></strong>：监听特定事件。</li><li><strong><code>$off(event, callback)</code></strong>：停止监听特定事件。</li><li><strong><code>$emit(event, ...args)</code></strong>：触发特定事件。</li><li><strong><code>$once(event, callback)</code></strong>：只监听一次特定事件。</li></ol><h4 id="解释" tabindex="-1">解释 <a class="header-anchor" href="#解释" aria-label="Permalink to &quot;解释&quot;">​</a></h4><ol><li><strong><code>$on</code></strong>：将事件和回调函数添加到 <code>events</code> 对象中。</li><li><strong><code>$off</code></strong>：如果没有传递回调函数，则移除所有监听。如果传递了回调函数，则只移除特定的回调。</li><li><strong><code>$emit</code></strong>：触发事件，调用所有注册的回调函数并传递参数。</li><li><strong><code>$once</code></strong>：使用一个包装函数 (<code>wrapper</code>) 包装原始回调函数，确保回调只执行一次，然后移除事件监听。</li></ol><h3 id="_4、computed-计算值为什么还可以依赖另外一个-computed-计算值" tabindex="-1">4、computed 计算值为什么还可以依赖另外一个 computed 计算值？ <a class="header-anchor" href="#_4、computed-计算值为什么还可以依赖另外一个-computed-计算值" aria-label="Permalink to &quot;4、computed 计算值为什么还可以依赖另外一个 computed 计算值？&quot;">​</a></h3><blockquote><p>在 Vue 中，<code>computed</code> 计算属性可以依赖其他 <code>computed</code> 计算属性，因为 Vue 的响应式系统能够正确地追踪依赖关系。</p></blockquote><h4 id="computed-计算属性的实现" tabindex="-1"><code>computed</code> 计算属性的实现 <a class="header-anchor" href="#computed-计算属性的实现" aria-label="Permalink to &quot;`computed` 计算属性的实现&quot;">​</a></h4><p><code>computed</code> 计算属性本质上是具有缓存功能的特殊方法。它们只有在其依赖的响应式属性发生变化时才会重新计算，否则返回缓存的值。</p><h3 id="_5、说一下-vm-set-原理" tabindex="-1">5、说一下 vm.$set 原理 <a class="header-anchor" href="#_5、说一下-vm-set-原理" aria-label="Permalink to &quot;5、说一下 vm.$set 原理&quot;">​</a></h3><p><code>vm.$set</code> 是 Vue 中用于在对象上设置属性并确保新属性是响应式的方法。其实现原理可以简化为以下几个步骤：</p><ol><li><strong>处理数组情况</strong>： 如果目标是数组，并且键是有效的数组索引，使用 <code>splice</code> 方法添加新元素以保持响应性。</li><li><strong>处理已有属性</strong>： 如果属性已经存在于对象中，直接赋值。</li><li><strong>处理新属性</strong>： 如果目标对象不是响应式对象，直接赋值新属性。</li><li><strong>添加响应式新属性</strong>： 如果目标对象是响应式的，通过 <code>defineReactive</code> 方法将新属性定义为响应式。这包括定义 getter 和 setter。</li><li><strong>通知依赖更新</strong>： 调用 <code>ob.dep.notify()</code> 通知所有依赖于该对象的 watchers 执行更新。</li></ol><h3 id="_6、怎么在-vue-中定义全局方法" tabindex="-1">6、怎么在 Vue 中定义全局方法？ <a class="header-anchor" href="#_6、怎么在-vue-中定义全局方法" aria-label="Permalink to &quot;6、怎么在 Vue 中定义全局方法？&quot;">​</a></h3><blockquote><p>在 Vue.js 中定义全局方法，可以通过多种方式实现，包括直接在 Vue 的原型对象上添加方法、使用 Vue 3 的全局 API (<code>app.config.globalProperties</code>)、以及通过混入 (mixin) 等方法。</p></blockquote><h4 id="方法一-在-vue-2-中通过-vue-prototype-定义全局方法" tabindex="-1">方法一：在 Vue 2 中通过 Vue.prototype 定义全局方法 <a class="header-anchor" href="#方法一-在-vue-2-中通过-vue-prototype-定义全局方法" aria-label="Permalink to &quot;方法一：在 Vue 2 中通过 Vue.prototype 定义全局方法&quot;">​</a></h4><h4 id="方法二-在-vue-3-中通过-app-config-globalproperties-定义全局方法" tabindex="-1">方法二：在 Vue 3 中通过 <code>app.config.globalProperties</code> 定义全局方法 <a class="header-anchor" href="#方法二-在-vue-3-中通过-app-config-globalproperties-定义全局方法" aria-label="Permalink to &quot;方法二：在 Vue 3 中通过 `app.config.globalProperties` 定义全局方法&quot;">​</a></h4><h4 id="方法三-使用混入-mixin" tabindex="-1">方法三：使用混入（Mixin） <a class="header-anchor" href="#方法三-使用混入-mixin" aria-label="Permalink to &quot;方法三：使用混入（Mixin）&quot;">​</a></h4><h3 id="_7、什么是vite" tabindex="-1">7、什么是Vite？ <a class="header-anchor" href="#_7、什么是vite" aria-label="Permalink to &quot;7、什么是Vite？&quot;">​</a></h3><p><strong>基于esbuild与Rollup，依靠浏览器自身ESM编译功能， 实现极致开发体验的新一代构建工具！</strong></p><p><code>Webpack</code>通过先将整个应用打包，再将打包后代码提供给<code>dev server</code>，开发者才能开始开发。</p><p><code>Vite</code>直接将源码交给浏览器，实现<code>dev server</code>秒开，浏览器显示页面需要相关模块时，再向<code>dev server</code>发起请求，服务器简单处理后，将该模块返回给浏览器，实现真正意义的按需加载。</p><h3 id="_8、vue2-0为什么不能检查数组的变化-该怎么解决" tabindex="-1">8、Vue2.0为什么不能检查数组的变化，该怎么解决？ <a class="header-anchor" href="#_8、vue2-0为什么不能检查数组的变化-该怎么解决" aria-label="Permalink to &quot;8、Vue2.0为什么不能检查数组的变化，该怎么解决？&quot;">​</a></h3><ul><li>无法检测数组/对象的新增</li><li>无法检测通过索引改变数组的操作。</li></ul><p>Vue检测数据的变动是通过Object.defineProperty实现的，所以无法监听数组的添加操作是可以理解的，因为是在构造函数中就已经为所有属性做了这个检测绑定操作。</p><ul><li>无法检测通过索引改变数组的操作。即vm.items[indexOfItem] = newValue？</li></ul><p><a href="https://cn.vuejs.org/v2/guide/list.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" target="_blank" rel="noreferrer">官方文档</a>中对于这两点都是简要的概括为“由于JavaScript的限制”无法实现，而Object.defineProperty是实现检测数据改变的方案，这个限制是指Object.defineProperty</p><h4 id="思考" tabindex="-1">思考 <a class="header-anchor" href="#思考" aria-label="Permalink to &quot;思考&quot;">​</a></h4><p><strong>vm.items[indexOfItem] = newValue真的不能被监听么？</strong></p><blockquote><p>Vue对数组的7个变异方法（push、pop、shift、unshift、splice、sort、reverse）实现了响应式。这里就不做测试了。我们测试一下通过索引改变数组的操作，能不能被监听到。</p><p>遍历数组，用Object.defineProperty对每一项进行监测</p></blockquote><p><strong>数组</strong></p><p>this.$set(array, index, data)</p><p><strong>对象</strong></p><ol><li>this.$set(obj, key ,value) - 可实现增、改</li><li>watch时添加<code>deep：true</code>深度监听，只能监听到属性值的变化，新增、删除属性无法监听</li></ol><h3 id="_9、vue-3-0中treeshaking特性是什么-并举例进行说明" tabindex="-1">9、Vue 3.0中Treeshaking特性是什么，并举例进行说明？ <a class="header-anchor" href="#_9、vue-3-0中treeshaking特性是什么-并举例进行说明" aria-label="Permalink to &quot;9、Vue 3.0中Treeshaking特性是什么，并举例进行说明？&quot;">​</a></h3><blockquote><p>Tree shaking<code>是一种通过清除多余代码方式来优化项目打包体积的技术，专业术语叫</code>Dead code elimination</p></blockquote><h3 id="_10、vue3-0-性能提升主要是通过哪几方面体现的" tabindex="-1">10、Vue3.0 性能提升主要是通过哪几方面体现的？ <a class="header-anchor" href="#_10、vue3-0-性能提升主要是通过哪几方面体现的" aria-label="Permalink to &quot;10、Vue3.0 性能提升主要是通过哪几方面体现的？&quot;">​</a></h3><p>可以看到，组件内部只有一个动态节点，剩余一堆都是静态节点，所以这里很多 <code>diff</code> 和遍历其实都是不需要的，造成性能浪费</p><p>因此，<code>Vue3</code>在编译阶段，做了进一步优化。主要有如下：</p><ul><li>diff算法优化</li><li>静态提升</li><li>事件监听缓存</li><li>SSR优化</li></ul><h4 id="diff算法优化" tabindex="-1">diff算法优化 <a class="header-anchor" href="#diff算法优化" aria-label="Permalink to &quot;diff算法优化&quot;">​</a></h4><p><code>vue3</code>在<code>diff</code>算法中相比<code>vue2</code>增加了静态标记</p><p>关于这个静态标记，其作用是为了会发生变化的地方添加一个<code>flag</code>标记，下次发生变化的时候直接找该地方进行比较</p><p>下图这里，已经标记静态节点的<code>p</code>标签在<code>diff</code>过程中则不会比较，把性能进一步提高</p><h4 id="静态提升" tabindex="-1">静态提升 <a class="header-anchor" href="#静态提升" aria-label="Permalink to &quot;静态提升&quot;">​</a></h4><p><code>Vue3</code>中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用</p><p>这样就免去了重复的创建节点，大型应用会受益于这个改动，免去了重复的创建操作，优化了运行时候的内存占用</p><h4 id="事件监听缓存" tabindex="-1">事件监听缓存 <a class="header-anchor" href="#事件监听缓存" aria-label="Permalink to &quot;事件监听缓存&quot;">​</a></h4><p>默认情况下绑定事件行为会被视为动态绑定，所以每次都会去追踪它的变化</p><h4 id="ssr优化" tabindex="-1">SSR优化 <a class="header-anchor" href="#ssr优化" aria-label="Permalink to &quot;SSR优化&quot;">​</a></h4><p>当静态内容大到一定量级时候，会用<code>createStaticVNode</code>方法在客户端去生成一个static node，这些静态<code>node</code>，会被直接<code>innerHtml</code>，就不需要创建对象，然后根据对象渲染</p><h4 id="源码体积" tabindex="-1">源码体积 <a class="header-anchor" href="#源码体积" aria-label="Permalink to &quot;源码体积&quot;">​</a></h4><p>相比<code>Vue2</code>，<code>Vue3</code>整体体积变小了，除了移出一些不常用的API，再重要的是<code>Tree shanking</code></p><p>任何一个函数，如<code>ref</code>、<code>reavtived</code>、<code>computed</code>等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小</p><h4 id="响应式系统" tabindex="-1">响应式系统 <a class="header-anchor" href="#响应式系统" aria-label="Permalink to &quot;响应式系统&quot;">​</a></h4><p><code>vue2</code>中采用 <code>defineProperty</code>来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加<code>getter</code>和<code>setter</code>，实现响应式</p><p><code>vue3</code>采用<code>proxy</code>重写了响应式系统，因为<code>proxy</code>可以对整个对象进行监听，所以不需要深度遍历</p><ul><li>可以监听动态属性的添加</li><li>可以监听到数组的索引和数组<code>length</code>属性</li><li>可以监听删除属性</li></ul><h3 id="_11、vue3-0的设计目标是什么-做了哪些优化" tabindex="-1">11、Vue3.0的设计目标是什么？做了哪些优化? <a class="header-anchor" href="#_11、vue3-0的设计目标是什么-做了哪些优化" aria-label="Permalink to &quot;11、Vue3.0的设计目标是什么？做了哪些优化?&quot;">​</a></h3>',81)]))}const f=o(r,[["render",d]]);export{h as __pageData,f as default};
